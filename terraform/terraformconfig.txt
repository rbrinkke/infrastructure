2024-12-17 18:33:21
/home/rob/repos/infrastructure/terraform/main.tf
----------------------------------------
terraform {
  required_providers {
    docker = {
      source  = "kreuzwerker/docker"
      version = "~> 3.0"
    }
    vault = {
      source  = "hashicorp/vault"
      version = "~> 3.0"
    }
  }
}

provider "docker" {
  host = "unix:///var/run/docker.sock"
}

provider "vault" {
  # Vault-adres en token worden opgehaald uit omgevingsvariabelen
  address = var.vault_address
  token   = var.vault_token
}

# Variabele voor Vault-adres
variable "vault_address" {
  description = "De URL van de Vault server"
  default     = "http://localhost:8600" # Pas dit aan naar je daadwerkelijke Vault-adres
}

# Variabele voor Vault-token (wordt ingesteld via omgevingsvariabele)
variable "vault_token" {
  description = "De authenticatietoken voor Vault"
  default     = null
}

# Haal configuratie op uit Vault
data "vault_kv_secret_v2" "terraform" {
  mount = "secret"
  name  = "terraform"
}

# Base modules
module "monitoring" {
  source = "./monitoring"
  traefik_network        = docker_network.traefik_network.name
  monitoring_network     = docker_network.monitoring_network.name
  grafana_admin_user     = data.vault_kv_secret_v2.terraform.data["grafana_admin_user"]
  grafana_admin_password = data.vault_kv_secret_v2.terraform.data["grafana_admin_password"]
}

module "auth" {
  source = "./auth"
  traefik_network         = docker_network.traefik_network.name
  auth_network            = docker_network.auth_network.name
  postgres_user           = data.vault_kv_secret_v2.terraform.data["postgres_user"]
  postgres_password       = data.vault_kv_secret_v2.terraform.data["postgres_password"]
  keycloak_admin          = data.vault_kv_secret_v2.terraform.data["keycloak_admin"]
  keycloak_admin_password = data.vault_kv_secret_v2.terraform.data["keycloak_admin_password"]
}

# Data stores
module "redis" {
  source             = "./redis"
  monitoring_network = docker_network.monitoring_network.name
  traefik_network    = docker_network.traefik_network.name
  redis_password     = data.vault_kv_secret_v2.terraform.data["redis_password"]
}

module "couchdb" {
  source              = "./couchdb"
  monitoring_network  = docker_network.monitoring_network.name
  traefik_network     = docker_network.traefik_network.name
  couchdb_user        = data.vault_kv_secret_v2.terraform.data["couchdb_user"]
  couchdb_password    = data.vault_kv_secret_v2.terraform.data["couchdb_password"]
  couchdb_secret      = data.vault_kv_secret_v2.terraform.data["couchdb_secret"]
}

module "minio" {
  source              = "./minio"
  monitoring_network  = docker_network.monitoring_network.name
  traefik_network     = docker_network.traefik_network.name
  minio_root_user     = data.vault_kv_secret_v2.terraform.data["minio_root_user"]
  minio_root_password = data.vault_kv_secret_v2.terraform.data["minio_root_password"]
}

module "flask" {
  source              = "./flask"
  monitoring_network  = docker_network.monitoring_network.name
  traefik_network     = docker_network.traefik_network.name
  redis_password      = data.vault_kv_secret_v2.terraform.data["redis_password"]
}

# Backup module
module "backup" {
  source              = "./backup"
  monitoring_network  = docker_network.monitoring_network.name
  traefik_network     = docker_network.traefik_network.name

  backup_password     = data.vault_kv_secret_v2.terraform.data["backup_password"]
  s3_backup_bucket    = data.vault_kv_secret_v2.terraform.data["s3_backup_bucket"]
  aws_access_key      = data.vault_kv_secret_v2.terraform.data["aws_access_key"]
  aws_secret_key      = data.vault_kv_secret_v2.terraform.data["aws_secret_key"]

  postgres_user       = data.vault_kv_secret_v2.terraform.data["postgres_user"]
  postgres_password   = data.vault_kv_secret_v2.terraform.data["postgres_password"]

  redis_password      = data.vault_kv_secret_v2.terraform.data["redis_password"]

  minio_root_user     = data.vault_kv_secret_v2.terraform.data["minio_root_user"]
  minio_root_password = data.vault_kv_secret_v2.terraform.data["minio_root_password"]

  couchdb_user        = data.vault_kv_secret_v2.terraform.data["couchdb_user"]
  couchdb_password    = data.vault_kv_secret_v2.terraform.data["couchdb_password"]

  depends_on = [
    module.auth,
    module.redis,
    module.couchdb,
    module.minio
  ]
}

module "security" {
  source             = "./security"
  monitoring_network = docker_network.monitoring_network.name
  traefik_network    = docker_network.traefik_network.name
  depends_on = [
    module.monitoring
  ]
}

# Logging module
module "logging" {
  source             = "./logging"
  monitoring_network = docker_network.monitoring_network.name
  traefik_network    = docker_network.traefik_network.name
  logging_network    = docker_network.logging_network.name
  retention_period   = tonumber(data.vault_kv_secret_v2.terraform.data["backup_retention_days"])

  depends_on = [
    module.monitoring
  ]
}



2024-12-17 18:33:21
/home/rob/repos/infrastructure/terraform/networks.tf
----------------------------------------
# Network resources
resource "docker_network" "traefik_network" {
  name       = data.vault_kv_secret_v2.terraform.data["traefik_network_name"]
  driver     = "overlay"
  attachable = true
}

resource "docker_network" "monitoring_network" {
  name       = data.vault_kv_secret_v2.terraform.data["monitoring_network_name"]
  driver     = "overlay"
  attachable = true
}

# In networks.tf, voeg toe aan de bestaande netwerken:
resource "docker_network" "auth_network" {
  name       = data.vault_kv_secret_v2.terraform.data["auth_network_name"]
  driver     = "overlay"
  attachable = true
}

# Add to networks.tf:
resource "docker_network" "logging_network" {
  name       = data.vault_kv_secret_v2.terraform.data["logging_network_name"]
  driver     = "overlay"
  attachable = true
}

2024-12-17 18:33:21
/home/rob/repos/infrastructure/terraform/outputs.tf
----------------------------------------
output "traefik_endpoint" {
  value       = "http://traefik.example.com"
  description = "The Traefik dashboard endpoint"
}

output "prometheus_endpoint" {
  value       = "http://prometheus.example.com"
  description = "The Prometheus endpoint"
}

output "grafana_endpoint" {
  value       = "http://grafana.example.com"
  description = "The Grafana endpoint"
}

output "cadvisor_endpoint" {
  value       = "http://cadvisor.example.com"
  description = "The cAdvisor endpoint"
}

2024-12-17 18:33:21
/home/rob/repos/infrastructure/terraform/traefik.tf
----------------------------------------
resource "docker_container" "traefik" {
  name  = "traefik"
  image = "traefik:v2.4"

  env = [
    "TRAEFIK_PROVIDERS_DOCKER=true",
    "TRAEFIK_API_INSECURE=false",
    "TRAEFIK_API_DASHBOARD=true",
    "TRAEFIK_ENTRYPOINTS_HTTP_ADDRESS=:80",
    "TRAEFIK_ENTRYPOINTS_HTTPS_ADDRESS=:443",
    "TRAEFIK_CERTIFICATESRESOLVERS_LE_ACME_EMAIL=${data.vault_kv_secret_v2.terraform.data["acme_email"]}",
    "TRAEFIK_CERTIFICATESRESOLVERS_LE_ACME_STORAGE=/letsencrypt/acme.json",
    "TRAEFIK_CERTIFICATESRESOLVERS_LE_ACME_HTTPCHALLENGE=true",
    "TRAEFIK_CERTIFICATESRESOLVERS_LE_ACME_HTTPCHALLENGE_ENTRYPOINT=http",
    "TRAEFIK_PROVIDERS_DOCKER_EXPOSEDBYDEFAULT=false",
  ]

  labels {
    label = "traefik.enable"
    value = "true"
  }

  labels {
    label = "traefik.http.routers.api.rule"
    value = "Host(`traefik.example.com`)"
  }

  labels {
    label = "traefik.http.routers.api.service"
    value = "api@internal"
  }

  labels {
    label = "traefik.http.routers.api.entrypoints"
    value = "https"
  }

  labels {
    label = "traefik.http.routers.api.tls"
    value = "true"
  }

  labels {
    label = "traefik.http.routers.api.middlewares"
    value = "auth"
  }

  volumes {
    host_path      = "/var/run/docker.sock"
    container_path = "/var/run/docker.sock"
  }

  volumes {
    host_path      = "/absolute/path/to/letsencrypt"
    container_path = "/letsencrypt"
  }

  ports {
    internal = 80
    external = 80
  }

  ports {
    internal = 443
    external = 443
  }

  ports {
    internal = 8080
    external = 8081
  }

  networks_advanced {
    name = docker_network.traefik_network.name
  }
}


2024-12-17 18:33:21
/home/rob/repos/infrastructure/terraform/variables.tf
----------------------------------------
variable "infrastructure_base_path" {
  type    = string
  default = "/var/lib/infrastructure"
}

2024-12-17 18:33:21
/home/rob/repos/infrastructure/terraform/couchdb/main.tf
----------------------------------------
resource "docker_container" "couchdb" {
  name  = "couchdb"
  image = "couchdb:latest"

  # Basis CouchDB configuratie
  upload {
    content = <<EOF
[couchdb]
single_node = true
max_document_size = 4294967296

[chttpd]
bind_address = 0.0.0.0
port = 5984

[httpd]
enable_cors = true

[cors]
credentials = true
origins = *
headers = accept, authorization, content-type, origin, referer
methods = GET, PUT, POST, DELETE

[admins]
${var.couchdb_user} = ${var.couchdb_password}
EOF
    file = "/opt/couchdb/etc/local.d/docker.ini"
  }

  env = [
    "COUCHDB_USER=${var.couchdb_user}",
    "COUCHDB_PASSWORD=${var.couchdb_password}",
    "COUCHDB_SINGLE_NODE=true"
  ]

  labels {
    label = "traefik.enable"
    value = "true"
  }

  labels {
    label = "traefik.http.routers.couchdb.rule"
    value = "Host(`db.example.com`)"
  }

  labels {
    label = "traefik.http.routers.couchdb.entrypoints"
    value = "https"
  }

  labels {
    label = "traefik.http.routers.couchdb.tls"
    value = "true"
  }

  labels {
    label = "traefik.http.services.couchdb.loadbalancer.server.port"
    value = "5984"
  }

  volumes {
    host_path      = "${var.infrastructure_base_path}/couchdb-data"
    container_path = "/opt/couchdb/data"
  }

  networks_advanced {
    name = var.monitoring_network
  }

  networks_advanced {
    name = var.traefik_network
  }

  healthcheck {
    test         = ["CMD-SHELL", "curl -f http://localhost:5984/_up || exit 1"]
    interval     = "10s"
    timeout      = "5s"
    retries      = 3
    start_period = "10s"
  }
}


2024-12-17 18:33:21
/home/rob/repos/infrastructure/terraform/couchdb/variables.tf
----------------------------------------
variable "monitoring_network" {
  description = "Name of the monitoring network"
  type        = string
}

variable "traefik_network" {
  description = "Name of the Traefik network"
  type        = string
}

variable "couchdb_user" {
  description = "CouchDB admin username"
  type        = string
  default     = "admin"
}

variable "couchdb_password" {
  description = "CouchDB admin password"
  type        = string
  sensitive   = true
}

variable "couchdb_secret" {
  description = "CouchDB cookie secret for cluster communication"
  type        = string
  sensitive   = true
}
variable "infrastructure_base_path" {
  type    = string
  default = "/var/lib/infrastructure"
}

2024-12-17 18:33:21
/home/rob/repos/infrastructure/terraform/couchdb/versions.tf
----------------------------------------
terraform {
  required_providers {
    docker = {
      source  = "kreuzwerker/docker"
      version = "~> 3.0"
    }
  }
}

2024-12-17 18:33:21
/home/rob/repos/infrastructure/terraform/security/main.tf
----------------------------------------
# security/main.tf
resource "docker_container" "trivy" {
  name     = "trivy"
  hostname = "trivy"  # Expliciete hostname toevoegen
  image    = "aquasec/trivy:latest"
  restart  = "unless-stopped"

  # Dynamische command opbouw met debug
  command = concat(
    [
      "server",
      "--listen", "0.0.0.0:8080",
      "--cache-dir", "/trivy-cache",
      "--debug"  # Debug logging toevoegen
    ],
    var.trivy_token != "" ? ["--token", var.trivy_token] : []
  )

  volumes {
    host_path      = "/var/run/docker.sock"
    container_path = "/var/run/docker.sock"
  }

  volumes {
    host_path      = "${var.infrastructure_base_path}/trivy-cache"
    container_path = "/trivy-cache"
  }

  networks_advanced {
    name = var.monitoring_network
  }

  networks_advanced {
    name = var.traefik_network
  }

  labels {
    label = "traefik.enable"
    value = "true"
  }

  labels {
    label = "traefik.http.routers.trivy.rule"
    value = "Host(`security.example.com`)"
  }

  labels {
    label = "traefik.http.routers.trivy.entrypoints"
    value = "https"
  }

  labels {
    label = "traefik.http.routers.trivy.tls"
    value = "true"
  }

  healthcheck {
    test         = ["CMD", "wget", "--spider", "--quiet", "http://localhost:8080/health"]
    interval     = "10s"  # Korter interval
    timeout      = "5s"
    retries      = 3
    start_period = "10s"
  }
}

# Automatische scanning service
resource "docker_container" "security_scanner" {
  name     = "security-scanner"
  hostname = "security-scanner"  # Expliciete hostname toevoegen
  image    = "alpine:latest"
  restart  = "unless-stopped"

  dns_search = ["traefik_network"]  # DNS search toevoegen

  command = [
    "/bin/sh", "-c",
    <<-EOT
      # Install required tools
      apk update && \
      apk add --no-cache \
        curl \
        jq \
        dcron \
        wget \
        bind-tools  # Voor DNS debugging

      # Create required directories
      mkdir -p /scanner/results /scanner/metrics

      # Test DNS resolving
      echo "Testing DNS resolution for trivy..."
      nslookup trivy || true

      # Create scan script
      cat > /scanner/scan.sh << 'EOF'
      #!/bin/sh

      echo "Starting vulnerability scan at $(date)"

      # Ensure trivy server is available
      echo "Testing connection to Trivy server..."
      until wget --spider -q http://trivy:8080/health; do
        echo "Waiting for Trivy server... ($(date))"
        echo "Current DNS resolution:"
        nslookup trivy || true
        sleep 5
      done

      echo "Trivy server is available"

      # Get list of running containers
      echo "Fetching container list..."
      containers=$(curl --unix-socket /var/run/docker.sock "http://localhost/containers/json" 2>/dev/null)

      if [ -z "$${containers}" ]; then
        echo "Error: Could not get container list"
        exit 1
      fi

      # Initialize metrics file
      echo "Initializing metrics..."
      echo "# HELP security_vulnerabilities_total Total number of vulnerabilities by severity" > /scanner/metrics/vulnerabilities.prom
      echo "# TYPE security_vulnerabilities_total gauge" >> /scanner/metrics/vulnerabilities.prom

      total_high=0
      total_critical=0

      # Scan each container
      echo "$${containers}" | jq -r '.[].Image' | while read -r image; do
        echo "Scanning image: $${image}"

        # Create result directory if it doesn't exist
        mkdir -p "/scanner/results/$(date +%Y%m%d)"

        # Run Trivy scan
        echo "Running Trivy scan for $${image}..."
        scan_result=$(curl -v -s -X POST "http://trivy:8080/scan" \
          -H "Content-Type: application/json" \
          -d "{\"image\":\"$${image}\"}" 2>/scanner/results/$(date +%Y%m%d)/curl_debug.log)

        # Save full scan result
        echo "$${scan_result}" > "/scanner/results/$(date +%Y%m%d)/$${image//\//_}.json"

        # Parse vulnerabilities
        high_vulns=$(echo "$${scan_result}" | jq '[.Results[] | select(.Vulnerabilities != null) | .Vulnerabilities[] | select(.Severity == "HIGH")] | length')
        critical_vulns=$(echo "$${scan_result}" | jq '[.Results[] | select(.Vulnerabilities != null) | .Vulnerabilities[] | select(.Severity == "CRITICAL")] | length')

        total_high=$((total_high + high_vulns))
        total_critical=$((total_critical + critical_vulns))

        if [ "$${high_vulns}" -gt 0 ] || [ "$${critical_vulns}" -gt 0 ]; then
          echo "WARNING: Found $${high_vulns} HIGH and $${critical_vulns} CRITICAL vulnerabilities in $${image}"

          # Export metrics for this image
          echo "security_vulnerabilities_high_total{image=\"$${image}\"} $${high_vulns}" >> /scanner/metrics/vulnerabilities.prom
          echo "security_vulnerabilities_critical_total{image=\"$${image}\"} $${critical_vulns}" >> /scanner/metrics/vulnerabilities.prom
        fi
      done

      # Export total metrics
      echo "security_vulnerabilities_high_total{image=\"total\"} $${total_high}" >> /scanner/metrics/vulnerabilities.prom
      echo "security_vulnerabilities_critical_total{image=\"total\"} $${total_critical}" >> /scanner/metrics/vulnerabilities.prom

      # Copy metrics to node exporter directory
      cp /scanner/metrics/vulnerabilities.prom /metrics/vulnerabilities.prom

      echo "Scan completed at $(date)"
EOF

      chmod +x /scanner/scan.sh

      # Setup daily scan
      mkdir -p /var/spool/cron/crontabs
      echo "0 3 * * * /scanner/scan.sh >> /scanner/scan.log 2>&1" > /var/spool/cron/crontabs/root
      chmod 0644 /var/spool/cron/crontabs/root

      # Initial scan
      echo "Running initial scan..."
      /scanner/scan.sh

      # Start cron
      exec crond -f
    EOT
  ]

  volumes {
    host_path      = "/var/run/docker.sock"
    container_path = "/var/run/docker.sock"
  }

  volumes {
    host_path      = "${var.infrastructure_base_path}/scanner-results"
    container_path = "/scanner/results"
  }

  volumes {
    host_path      = "${var.infrastructure_base_path}/metrics"
    container_path = "/scanner/metrics"
  }

  volumes {
    host_path      = "${var.infrastructure_base_path}/metrics"
    container_path = "/metrics"
  }

  networks_advanced {
    name = var.monitoring_network
  }

  networks_advanced {
    name = var.traefik_network  # Toevoegen aan traefik netwerk
  }

  healthcheck {
    test         = ["CMD", "wget", "--spider", "--quiet", "http://trivy:8080/health"]
    interval     = "30s"
    timeout      = "10s"
    retries      = 3
    start_period = "40s"
  }

  depends_on = [
    docker_container.trivy
  ]
}

# Prometheus metrics exporter voor security scans
resource "docker_container" "security_metrics" {
  name  = "security-metrics"
  image = "prom/node-exporter:latest"

  command = [
    "--path.rootfs=/host",
    "--collector.textfile.directory=/metrics"
  ]

  volumes {
    host_path      = "${var.infrastructure_base_path}/metrics"
    container_path = "/metrics"
    read_only      = true
  }

  networks_advanced {
    name = var.monitoring_network
  }

  labels {
    label = "prometheus.io/scrape"
    value = "true"
  }

  depends_on = [
    docker_container.security_scanner
  ]
}

2024-12-17 18:33:21
/home/rob/repos/infrastructure/terraform/security/variables.tf
----------------------------------------
# security/variables.tf
variable "monitoring_network" {
  description = "Name of the monitoring network"
  type        = string
}

variable "traefik_network" {
  description = "Name of the Traefik network"
  type        = string
}

variable "trivy_token" {
  description = "API token for Trivy vulnerability scanner"
  type        = string
  sensitive   = true
  default     = ""  # Maak de token optioneel voor development
}
variable "infrastructure_base_path" {
  type    = string
  default = "/var/lib/infrastructure"
}

2024-12-17 18:33:21
/home/rob/repos/infrastructure/terraform/security/versions.tf
----------------------------------------
# security/versions.tf
terraform {
  required_providers {
    docker = {
      source  = "kreuzwerker/docker"
      version = "~> 3.0"
    }
  }
}

2024-12-17 18:33:21
/home/rob/repos/infrastructure/terraform/minio/main.tf
----------------------------------------
# minio/main.tf
resource "docker_container" "minio" {
  name  = "minio"
  image = "minio/minio:latest"

  command = ["server", "/data", "--console-address", ":9001"]

  env = [
    "MINIO_ROOT_USER=${var.minio_root_user}",
    "MINIO_ROOT_PASSWORD=${var.minio_root_password}"
  ]

  labels {
    label = "traefik.enable"
    value = "true"
  }

  # API Endpoint
  labels {
    label = "traefik.http.routers.minio-api.rule"
    value = "Host(`s3.example.com`)"
  }
  labels {
    label = "traefik.http.routers.minio-api.entrypoints"
    value = "https"
  }
  labels {
    label = "traefik.http.routers.minio-api.tls"
    value = "true"
  }
  labels {
    label = "traefik.http.services.minio-api.loadbalancer.server.port"
    value = "9000"
  }

  # Console UI
  labels {
    label = "traefik.http.routers.minio-console.rule"
    value = "Host(`minio.example.com`)"
  }
  labels {
    label = "traefik.http.routers.minio-console.entrypoints"
    value = "https"
  }
  labels {
    label = "traefik.http.routers.minio-console.tls"
    value = "true"
  }
  labels {
    label = "traefik.http.services.minio-console.loadbalancer.server.port"
    value = "9001"
  }

  volumes {
    host_path      = "${var.infrastructure_base_path}/minio-data"
    container_path = "/data"
  }

  networks_advanced {
    name = var.monitoring_network
  }
  
  networks_advanced {
    name = var.traefik_network
  }

  healthcheck {
    test         = ["CMD", "curl", "-f", "http://localhost:9000/minio/health/ready"]
    interval     = "30s"
    timeout      = "10s"
    retries      = 3
    start_period = "30s"
  }
}

# minio/variables.tf
variable "monitoring_network" {
  description = "Name of the monitoring network"
  type        = string
}

variable "traefik_network" {
  description = "Name of the Traefik network"
  type        = string
}

variable "minio_root_user" {
  description = "MinIO root username"
  type        = string
  default     = "admin"
}

variable "minio_root_password" {
  description = "MinIO root password"
  type        = string
  sensitive   = true
}

2024-12-17 18:33:21
/home/rob/repos/infrastructure/terraform/minio/variables.tf
----------------------------------------
variable "infrastructure_base_path" {
  type    = string
  default = "/var/lib/infrastructure"
}

2024-12-17 18:33:21
/home/rob/repos/infrastructure/terraform/minio/versions.tf
----------------------------------------
terraform {
  required_providers {
    docker = {
      source  = "kreuzwerker/docker"
      version = "~> 3.0"
    }
  }
}

2024-12-17 18:33:21
/home/rob/repos/infrastructure/terraform/logging/loki.tf
----------------------------------------
# logging/loki.tf
resource "local_file" "loki_config" {
  filename = "${abspath(path.module)}/config/loki-config.yaml"
  content  = <<-EOT
auth_enabled: false

server:
  http_listen_port: 3100

common:
  path_prefix: /loki
  storage:
    filesystem:
      chunks_directory: /loki/chunks
      rules_directory: /loki/rules
  replication_factor: 1
  ring:
    kvstore:
      store: inmemory

schema_config:
  configs:
    - from: 2020-01-01
      store: boltdb-shipper
      object_store: filesystem
      schema: v11
      index:
        prefix: index_
        period: 24h

limits_config:
  retention_period: 168h

compactor:
  working_directory: /loki/compactor
  shared_store: filesystem
  compaction_interval: 10m
EOT
}

resource "docker_container" "loki" {
  name  = "loki"
  image = "grafana/loki:latest"

  command = ["--config.file=/etc/loki/config.yaml"]

  volumes {
    host_path      = local_file.loki_config.filename
    container_path = "/etc/loki/config.yaml"
    read_only      = true
  }

  volumes {
    host_path      = "${var.infrastructure_base_path}/loki-data"
    container_path = "/loki"
  }

  ports {
    internal = 3100
    external = 3100
  }

  labels {
    label = "traefik.enable"
    value = "true"
  }

  labels {
    label = "traefik.http.routers.loki.rule"
    value = "Host(`loki.example.com`)"
  }

  labels {
    label = "traefik.http.routers.loki.entrypoints"
    value = "https"
  }

  labels {
    label = "traefik.http.routers.loki.tls"
    value = "true"
  }

  labels {
    label = "traefik.http.services.loki.loadbalancer.server.port"
    value = "3100"
  }

  networks_advanced {
    name = var.monitoring_network
  }

  networks_advanced {
    name = var.traefik_network
  }

  networks_advanced {
    name = var.logging_network
  }

  restart = "unless-stopped"

  healthcheck {
    test         = ["CMD-SHELL", "wget --no-verbose --tries=1 --spider http://localhost:3100/ready || exit 1"]
    interval     = "30s"
    timeout      = "5s"
    retries      = 3
    start_period = "30s"
  }
}

2024-12-17 18:33:21
/home/rob/repos/infrastructure/terraform/logging/promtail.tf
----------------------------------------
# logging/promtail.tf
resource "local_file" "promtail_configuration" {
  filename = "${abspath(path.module)}/config/promtail-config.yaml"
  content  = <<-EOT
server:
  http_listen_port: 9080
  grpc_listen_port: 0

positions:
  filename: /tmp/positions.yaml

clients:
  - url: http://loki:3100/loki/api/v1/push

scrape_configs:
  - job_name: docker
    static_configs:
      - targets:
          - localhost
        labels:
          job: docker
          __path__: /var/lib/docker/containers/*/*-json.log
    pipeline_stages:
      - json:
          expressions:
            output: log
            stream: stream
            timestamp: time
      - timestamp:
          source: timestamp
          format: RFC3339Nano
      - labels:
          stream:
      - output:
          source: output
EOT
}

resource "docker_container" "promtail_service" {
  name  = "promtail"
  image = "grafana/promtail:latest"

  command = ["-config.file=/etc/promtail/config.yaml"]

  # Run as root to access logs
  user = "root"

  volumes {
    host_path      = local_file.promtail_configuration.filename
    container_path = "/etc/promtail/config.yaml"
    read_only      = true
  }

  volumes {
    host_path      = "/var/lib/docker/containers"
    container_path = "/var/lib/docker/containers"
    read_only      = true
  }

  # Add Docker socket for container discovery
  volumes {
    host_path      = "/var/run/docker.sock"
    container_path = "/var/run/docker.sock"
    read_only      = true
  }

  networks_advanced {
    name = var.logging_network
  }

  networks_advanced {
    name = var.monitoring_network
  }

  networks_advanced {
    name = var.traefik_network
  }

  restart = "unless-stopped"

  healthcheck {
    test         = ["CMD-SHELL", "wget --no-verbose --tries=1 --spider http://localhost:9080/ready || exit 1"]
    interval     = "30s"
    timeout      = "5s"
    retries      = 3
    start_period = "30s"
  }

  depends_on = [
    docker_container.loki
  ]
}

2024-12-17 18:33:21
/home/rob/repos/infrastructure/terraform/logging/variables.tf
----------------------------------------
# logging/variables.tf

variable "monitoring_network" {
  description = "Naam van het monitoring netwerk"
  type        = string
}

variable "traefik_network" {
  description = "Naam van het Traefik netwerk"
  type        = string
}

variable "logging_network" {
  description = "Naam van het logging netwerk"
  type        = string
}

variable "retention_period" {
  description = "Retentieperiode in dagen"
  type        = number
}

variable "infrastructure_base_path" {
  type    = string
  default = "/var/lib/infrastructure"
}

2024-12-17 18:33:21
/home/rob/repos/infrastructure/terraform/logging/versions.tf
----------------------------------------
terraform {
  required_providers {
    docker = {
      source  = "kreuzwerker/docker"
      version = "~> 3.0"
    }
  }
}

2024-12-17 18:33:21
/home/rob/repos/infrastructure/terraform/backup/main.tf
----------------------------------------
# backup/main.tf
resource "docker_container" "backup_service" {
  name  = "backup-service"
  image = "alpine:latest"
  
  restart = "unless-stopped"
  
  command = [
    "/bin/sh", "-c",
    <<-EOT
      # Install required tools
      apk update && \
      apk add --no-cache \
        restic \
        postgresql-client \
        curl \
        jq \
        redis \
        mc \
        dcron
      
      # Create backup directory
      mkdir -p /backup/temp
      
      # Setup backup script
      cat > /backup/backup.sh << 'EOF'
      #!/bin/sh
      
      # Set timestamp
      TIMESTAMP=$(date +%Y%m%d_%H%M%S)
      
      echo "Starting backup process - $${TIMESTAMP}"
      
      # Create temp directory for this backup
      BACKUP_DIR="/backup/temp/$${TIMESTAMP}"
      mkdir -p $${BACKUP_DIR}
      
      # Backup PostgreSQL
      echo "Backing up PostgreSQL..."
      PGPASSWORD=$${POSTGRES_PASSWORD} pg_dump -h postgres -U $${POSTGRES_USER} -d keycloak > $${BACKUP_DIR}/postgres_keycloak.sql
      
      # Backup CouchDB
      echo "Backing up CouchDB..."
      curl -u $${COUCHDB_USER}:$${COUCHDB_PASSWORD} -X GET http://couchdb:5984/_all_dbs | jq -r '.[]' | \
        while read -r db; do
          curl -u $${COUCHDB_USER}:$${COUCHDB_PASSWORD} -X GET "http://couchdb:5984/$${db}/_all_docs?include_docs=true" \
            > $${BACKUP_DIR}/couchdb_$${db}.json
        done
      
      # Backup Redis
      echo "Backing up Redis..."
      redis-cli -h redis -a $${REDIS_PASSWORD} --rdb $${BACKUP_DIR}/redis_dump.rdb
      
      # Create restic backup
      echo "Creating restic backup..."
      restic -r s3:s3.amazonaws.com/$${S3_BACKUP_BUCKET}/restic backup $${BACKUP_DIR}
      
      # Cleanup old backups
      echo "Cleaning up old backups..."
      restic -r s3:s3.amazonaws.com/$${S3_BACKUP_BUCKET}/restic forget \
        --keep-last 7 \
        --keep-daily 7 \
        --keep-weekly 4 \
        --keep-monthly 6 \
        --prune
      
      # Cleanup temp directory
      rm -rf $${BACKUP_DIR}
      
      echo "Backup completed successfully"
EOF
      
      # Make backup script executable
      chmod +x /backup/backup.sh
      
      # Create cron directory if it doesn't exist
      mkdir -p /var/spool/cron/crontabs
      
      # Setup cron job
      echo "0 2 * * * /backup/backup.sh >> /backup/backup.log 2>&1" > /var/spool/cron/crontabs/root
      
      # Set proper permissions
      chmod 0644 /var/spool/cron/crontabs/root
      
      # Run initial backup
      echo "Running initial backup..."
      /backup/backup.sh
      
      # Start cron daemon in foreground
      exec crond -f
    EOT
  ]

  env = [
    "RESTIC_PASSWORD=${var.backup_password}",
    "AWS_ACCESS_KEY_ID=${var.aws_access_key}",
    "AWS_SECRET_ACCESS_KEY=${var.aws_secret_key}",
    "S3_BACKUP_BUCKET=${var.s3_backup_bucket}",
    "POSTGRES_USER=${var.postgres_user}",
    "POSTGRES_PASSWORD=${var.postgres_password}",
    "REDIS_PASSWORD=${var.redis_password}",
    "MINIO_ROOT_USER=${var.minio_root_user}",
    "MINIO_ROOT_PASSWORD=${var.minio_root_password}",
    "COUCHDB_USER=${var.couchdb_user}",
    "COUCHDB_PASSWORD=${var.couchdb_password}"
  ]

  volumes {
    host_path      = "${var.infrastructure_base_path}/backup-data"
    container_path = "/backup"
  }

  networks_advanced {
    name = var.monitoring_network
  }
  
  networks_advanced {
    name = var.traefik_network
  }

  labels {
    label = "traefik.enable"
    value = "true"
  }

  labels {
    label = "traefik.http.routers.backup.rule"
    value = "Host(`backup.example.com`)"
  }

  labels {
    label = "traefik.http.routers.backup.entrypoints"
    value = "https"
  }

  labels {
    label = "traefik.http.routers.backup.tls"
    value = "true"
  }
}

2024-12-17 18:33:21
/home/rob/repos/infrastructure/terraform/backup/outputs.tf
----------------------------------------
# backup/outputs.tf

output "backup_service_name" {
  description = "Name of the backup service container"
  value       = docker_container.backup_service.name
}

output "backup_service_id" {
  description = "ID of the backup service container"
  value       = docker_container.backup_service.id
}

2024-12-17 18:33:21
/home/rob/repos/infrastructure/terraform/backup/variables.tf
----------------------------------------
# backup/variables.tf
variable "monitoring_network" {
  description = "Name of the monitoring network"
  type        = string
}

variable "traefik_network" {
  description = "Name of the Traefik network"
  type        = string
}

variable "backup_password" {
  description = "Password for backup encryption"
  type        = string
  sensitive   = true
}

variable "s3_backup_bucket" {
  description = "S3 bucket name for backups"
  type        = string
}

variable "aws_access_key" {
  description = "AWS access key for S3 backup storage"
  type        = string
  sensitive   = true
}

variable "aws_secret_key" {
  description = "AWS secret key for S3 backup storage"
  type        = string
  sensitive   = true
}

variable "backup_retention_days" {
  description = "Number of days to retain backups"
  type        = number
  default     = 30
}

variable "postgres_user" {
  description = "PostgreSQL username for backup"
  type        = string
}

variable "postgres_password" {
  description = "PostgreSQL password for backup"
  type        = string
  sensitive   = true
}


# Voeg toe aan backup/variables.tf:

variable "redis_password" {
  description = "Redis password for authentication"
  type        = string
  sensitive   = true
}

variable "minio_root_user" {
  description = "MinIO root username"
  type        = string
  default     = "admin"
}

variable "minio_root_password" {
  description = "MinIO root password"
  type        = string
  sensitive   = true
}

variable "couchdb_user" {
  description = "CouchDB admin username"
  type        = string
  default     = "admin"
}

variable "couchdb_password" {
  description = "CouchDB admin password"
  type        = string
  sensitive   = true
}
variable "infrastructure_base_path" {
  type    = string
  default = "/var/lib/infrastructure"
}

2024-12-17 18:33:21
/home/rob/repos/infrastructure/terraform/backup/versions.tf
----------------------------------------
terraform {
  required_providers {
    docker = {
      source  = "kreuzwerker/docker"
      version = "~> 3.0"
    }
  }
}

2024-12-17 18:33:21
/home/rob/repos/infrastructure/terraform/flask/main.tf
----------------------------------------
resource "docker_container" "flask" {
  name  = "flask"
  image = "python:3.9-slim"

  command = [
    "sh", "-c",
    "apt-get update && apt-get install -y curl && pip install flask redis prometheus_client gunicorn && gunicorn --bind 0.0.0.0:5000 app:app"
  ]

  working_dir = "/app"

  env = [
    "FLASK_ENV=production",
    "REDIS_HOST=redis",
    "REDIS_PORT=6379",
    "REDIS_PASSWORD=${var.redis_password}",
    "WORKERS=4"
  ]

  labels {
    label = "traefik.enable"
    value = "true"
  }

  labels {
    label = "traefik.http.routers.flask.rule"
    value = "Host(`app.example.com`)"
  }

  labels {
    label = "traefik.http.routers.flask.entrypoints"
    value = "https"
  }

  labels {
    label = "traefik.http.routers.flask.tls"
    value = "true"
  }

  labels {
    label = "traefik.http.services.flask.loadbalancer.server.port"
    value = "5000"
  }

  volumes {
    host_path      = "${var.infrastructure_base_path}/flask-app"
    container_path = "/app"
  }

  networks_advanced {
    name = var.monitoring_network
  }
  
  networks_advanced {
    name = var.traefik_network
  }

  healthcheck {
    test         = ["CMD", "curl", "-f", "http://localhost:5000/health"]
    interval     = "30s"
    timeout      = "10s"
    retries      = 3
    start_period = "60s"
  }
}

2024-12-17 18:33:21
/home/rob/repos/infrastructure/terraform/flask/variables.tf
----------------------------------------
variable "monitoring_network" {
  description = "Name of the monitoring network"
  type        = string
}

variable "traefik_network" {
  description = "Name of the Traefik network"
  type        = string
}

variable "redis_password" {
  description = "Redis password for authentication"
  type        = string
  sensitive   = true
}
variable "infrastructure_base_path" {
  type    = string
  default = "/var/lib/infrastructure"
}

2024-12-17 18:33:21
/home/rob/repos/infrastructure/terraform/flask/versions.tf
----------------------------------------
terraform {
  required_providers {
    docker = {
      source  = "kreuzwerker/docker"
      version = "~> 3.0"
    }
  }
}

2024-12-17 18:33:21
/home/rob/repos/infrastructure/terraform/auth/keycloak.tf
----------------------------------------
resource "docker_container" "keycloak" {
  name  = "keycloak"
  image = "quay.io/keycloak/keycloak:latest"
  
  command = [
    "start",
    "--db=postgres",
    "--hostname=https://auth.example.com",      # Nu een volledige URL
    "--hostname-admin=https://auth.example.com", # Volledige URL
    "--proxy-headers=forwarded",
    "--http-enabled=true",
    "--http-port=8080",
    "--https-port=8443"
  ]
  
  env = [
    "KC_DB_URL=jdbc:postgresql://postgres:5432/keycloak",
    "KC_DB_USERNAME=${var.postgres_user}",
    "KC_DB_PASSWORD=${var.postgres_password}",
    "KC_BOOTSTRAP_ADMIN_USERNAME=${var.keycloak_admin}",
    "KC_BOOTSTRAP_ADMIN_PASSWORD=${var.keycloak_admin_password}",
    "KEYCLOAK_ADMIN=${var.keycloak_admin}",
    "KEYCLOAK_ADMIN_PASSWORD=${var.keycloak_admin_password}"
  ]
  
  depends_on = [
    docker_container.postgres
  ]
  
  labels {
    label = "traefik.enable"
    value = "true"
  }
  
  labels {
    label = "traefik.http.routers.keycloak.rule"
    value = "Host(auth.example.com)"
  }
  
  labels {
    label = "traefik.http.routers.keycloak.entrypoints"
    value = "https"
  }
  
  labels {
    label = "traefik.http.routers.keycloak.tls"
    value = "true"
  }
  
  labels {
    label = "traefik.http.services.keycloak.loadbalancer.server.port"
    value = "8080"
  }
  
  networks_advanced {
    name = var.auth_network
  }
  
  networks_advanced {
    name = var.traefik_network
  }

  healthcheck {
    test         = ["CMD", "curl", "-f", "http://localhost:8080/health"]
    interval     = "30s"
    timeout      = "10s"
    retries      = 3
    start_period = "30s"
  }
}

2024-12-17 18:33:21
/home/rob/repos/infrastructure/terraform/auth/postgresql.tf
----------------------------------------
resource "docker_container" "postgres" {
  name  = "postgres"
  image = "postgres:13"
  
  env = [
    "POSTGRES_DB=keycloak",
    "POSTGRES_USER=${var.postgres_user}",
    "POSTGRES_PASSWORD=${var.postgres_password}"
  ]
  
  volumes {
    host_path      = "${var.infrastructure_base_path}/postgres-data"
    container_path = "/var/lib/postgresql/data"
  }
  
  networks_advanced {
    name = var.auth_network
  }
  
  healthcheck {
    test         = ["CMD-SHELL", "pg_isready -U ${var.postgres_user} -d keycloak"]
    interval     = "10s"
    timeout      = "5s"
    retries      = 5
    start_period = "10s"
  }
}

2024-12-17 18:33:21
/home/rob/repos/infrastructure/terraform/auth/variables.tf
----------------------------------------
variable "auth_network" {
  description = "Name of the authentication network"
  type        = string
}

variable "traefik_network" {
  description = "Name of the Traefik network"
  type        = string
}

variable "postgres_user" {
  description = "PostgreSQL username"
  type        = string
  default     = "keycloak"
}

variable "postgres_password" {
  description = "PostgreSQL password"
  type        = string
  sensitive   = true
}

variable "keycloak_admin" {
  description = "Keycloak admin username"
  type        = string
  default     = "admin"
}

variable "keycloak_admin_password" {
  description = "Keycloak admin password"
  type        = string
  sensitive   = true
}

variable "infrastructure_base_path" {
  type    = string
  default = "/var/lib/infrastructure"
}

2024-12-17 18:33:21
/home/rob/repos/infrastructure/terraform/auth/versions.tf
----------------------------------------
terraform {
  required_providers {
    docker = {
      source  = "kreuzwerker/docker"
      version = "~> 3.0"
    }
  }
}

2024-12-17 18:33:21
/home/rob/repos/infrastructure/terraform/monitoring/cadvisor.tf
----------------------------------------
resource "docker_container" "cadvisor" {
  name  = "cadvisor"
  image = "gcr.io/cadvisor/cadvisor:latest"

  volumes {
    host_path      = "/"
    container_path = "/rootfs"
    read_only      = true
  }
  volumes {
    host_path      = "/var/run"
    container_path = "/var/run"
    read_only      = true
  }
  volumes {
    host_path      = "/sys"
    container_path = "/sys"
    read_only      = true
  }
  volumes {
    host_path      = "/var/lib/docker/"
    container_path = "/var/lib/docker"
    read_only      = true
  }

  ports {
    internal = 8080
    external = 8082  # Veranderd van 8080 naar 8082
  }

  labels {
    label = "traefik.enable"
    value = "true"
  }
  labels {
    label = "traefik.http.routers.cadvisor.rule"
    value = "Host(`cadvisor.example.com`)"
  }
  labels {
    label = "traefik.http.routers.cadvisor.entrypoints"
    value = "https"
  }
  labels {
    label = "traefik.http.routers.cadvisor.tls"
    value = "true"
  }

  networks_advanced {
    name = var.monitoring_network
  }
  
  networks_advanced {
    name = var.traefik_network
  }
}

2024-12-17 18:33:21
/home/rob/repos/infrastructure/terraform/monitoring/grafana.tf
----------------------------------------
# Grafana configuratie
resource "docker_service" "grafana" {
  name = "grafana"

  mode {
    replicated {
      replicas = 1
    }
  }

  task_spec {
    container_spec {
      image = "grafana/grafana:latest"

      env = {
        "GF_SECURITY_ADMIN_USER"     = var.grafana_admin_user
        "GF_SECURITY_ADMIN_PASSWORD" = var.grafana_admin_password
      }

      labels {
        label = "traefik.enable"
        value = "true"
      }
      labels {
        label = "traefik.http.routers.grafana.rule"
        value = "Host(`grafana.example.com`)"
      }
    }

    networks_advanced {
    name = var.monitoring_network
  }
  
  networks_advanced {
      name = var.traefik_network
    }
  }

  endpoint_spec {
    ports {
      published_port = 3000
      target_port    = 3000
    }
  }
}

2024-12-17 18:33:21
/home/rob/repos/infrastructure/terraform/monitoring/node_exporter.tf
----------------------------------------
resource "docker_container" "node_exporter" {
  name  = "node_exporter"
  image = "prom/node-exporter:latest"

  ports {
    internal = 9100
    external = 9100
  }

  labels {
    label = "traefik.enable"
    value = "true"
  }
  labels {
    label = "traefik.http.routers.node_exporter.rule"
    value = "Host(`node-exporter.example.com`)"
  }
  labels {
    label = "traefik.http.routers.node_exporter.entrypoints"
    value = "https"
  }
  labels {
    label = "traefik.http.routers.node_exporter.tls"
    value = "true"
  }

  networks_advanced {
    name = var.monitoring_network
  }
  
  networks_advanced {
    name = var.traefik_network
  }
}

2024-12-17 18:33:21
/home/rob/repos/infrastructure/terraform/monitoring/prometheus.tf
----------------------------------------
resource "docker_container" "prometheus" {
  name  = "prometheus"
  image = "prom/prometheus:latest"

  volumes {
    host_path      = "${abspath(path.module)}/config/prometheus.yml"
    container_path = "/etc/prometheus/prometheus.yml"
    read_only      = true
  }

  ports {
    internal = 9090
    external = 9090
  }

  labels {
    label = "traefik.enable"
    value = "true"
  }
  labels {
    label = "traefik.http.routers.prometheus.rule"
    value = "Host(`prometheus.example.com`)"
  }
  labels {
    label = "traefik.http.routers.prometheus.entrypoints"
    value = "https"
  }
  labels {
    label = "traefik.http.routers.prometheus.tls"
    value = "true"
  }

  networks_advanced {
    name = var.monitoring_network
  }
  
  networks_advanced {
    name = var.traefik_network
  }
}

2024-12-17 18:33:21
/home/rob/repos/infrastructure/terraform/monitoring/variables.tf
----------------------------------------
variable "traefik_network" {
  description = "Name of the Traefik network"
  type        = string
}

variable "monitoring_network" {
  description = "Name of the monitoring network"
  type        = string
}

variable "grafana_admin_user" {
  description = "Grafana admin username"
  type        = string
  default     = "admin"
}

variable "grafana_admin_password" {
  description = "Grafana admin password"
  type        = string
  sensitive   = true
}

2024-12-17 18:33:21
/home/rob/repos/infrastructure/terraform/monitoring/versions.tf
----------------------------------------
terraform {
  required_providers {
    docker = {
      source  = "kreuzwerker/docker"
      version = "~> 3.0"
    }
  }
}

2024-12-17 18:33:21
/home/rob/repos/infrastructure/terraform/redis/main.tf
----------------------------------------
# redis/main.tf
resource "docker_container" "redis" {
  name  = "redis"
  image = "redis:7-alpine"

  command = [
    "redis-server",
    "--requirepass ${var.redis_password}",
    "--maxmemory ${var.max_memory}",
    "--maxmemory-policy ${var.eviction_policy}"
  ]

  labels {
    label = "traefik.enable"
    value = "true"
  }

  labels {
    label = "traefik.http.routers.redis.rule"
    value = "Host(`redis.example.com`)"
  }

  labels {
    label = "traefik.http.routers.redis.entrypoints"
    value = "https"
  }

  labels {
    label = "traefik.http.routers.redis.tls"
    value = "true"
  }

  labels {
    label = "traefik.http.services.redis.loadbalancer.server.port"
    value = "6379"
  }

  healthcheck {
    test         = ["CMD", "redis-cli", "ping"]
    interval     = "5s"
    timeout      = "3s"
    retries      = 3
    start_period = "5s"
  }

  volumes {
    host_path      = "${var.infrastructure_base_path}/redis-data"
    container_path = "/data"
  }

  networks_advanced {
    name = var.monitoring_network
  }
  
  networks_advanced {
    name = var.traefik_network
  }
}

resource "docker_container" "redis_exporter" {
  name  = "redis_exporter"
  image = "oliver006/redis_exporter:latest"

  env = [
    "REDIS_ADDR=redis://redis:6379",
    "REDIS_PASSWORD=${var.redis_password}"
  ]

  ports {
    internal = 9121
    external = 9121
  }

  labels {
    label = "traefik.enable"
    value = "true"
  }

  labels {
    label = "traefik.http.routers.redis-exporter.rule"
    value = "Host(`redis-metrics.example.com`)"
  }

  labels {
    label = "traefik.http.routers.redis-exporter.entrypoints"
    value = "https"
  }

  labels {
    label = "traefik.http.routers.redis-exporter.tls"
    value = "true"
  }

  networks_advanced {
    name = var.monitoring_network
  }

  networks_advanced {
    name = var.traefik_network
  }

  depends_on = [
    docker_container.redis
  ]
}

# redis/variables.tf
variable "monitoring_network" {
  description = "Name of the monitoring network"
  type        = string
}

variable "traefik_network" {
  description = "Name of the Traefik network"
  type        = string
}

variable "redis_password" {
  description = "Redis password for authentication"
  type        = string
  sensitive   = true
}

variable "max_memory" {
  description = "Maximum memory Redis can use"
  type        = string
  default     = "256mb"
}

variable "eviction_policy" {
  description = "Redis eviction policy"
  type        = string
  default     = "allkeys-lru"
}

2024-12-17 18:33:21
/home/rob/repos/infrastructure/terraform/redis/variables.tf
----------------------------------------
variable "infrastructure_base_path" {
  type    = string
  default = "/var/lib/infrastructure"
}

2024-12-17 18:33:21
/home/rob/repos/infrastructure/terraform/redis/versions.tf
----------------------------------------
terraform {
  required_providers {
    docker = {
      source  = "kreuzwerker/docker"
      version = "~> 3.0"
    }
  }
}

